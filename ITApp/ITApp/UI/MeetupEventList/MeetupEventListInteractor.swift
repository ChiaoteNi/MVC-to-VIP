//
//  MeetupEventListInteractor.swift
//  ITApp
//
//  Created by Chiaote Ni on 2020/10/28.
//  Copyright (c) 2020 iOS@Taipei in iPlayground. All rights reserved.
//
//  This file was generated by iOS@Taipei's Clean Architecture Xcode Templates, which
//  is goaled to help you apply clean architecture to your iOS projects,
//

/*
 Interactor: 任務指派者，叫worker幫ViewController做事
 ex: 透過worker拉API/DB資料，回傳資料的排序，開啟部分監聽，圖片壓縮，邏輯運算...等等
 反正跟UI完全無關的全部塞這就對了www
 */

import Foundation

protocol MeetupEventListBusinessLogic {
    func fetchMeetupEvents(request: MeetupEventList.FetchEvents.Request)
    func tapFavorite(request: MeetupEventList.TapFavorite.Request)
    func subscribeFavoriteUpdate(request: MeetupEventList.SubscribeFavoriteUpdate.Request)
    func unsubscribeFavoriteUpdate(request: MeetupEventList.UnsubscribeFavoriteUpdate.Request)
}

final class MeetupEventListInteractor: MeetupEventListBusinessLogic {
    
    var presenter: MeetupEventListPresentationLogic?
    
    private var fetchMeetupEventWorker: MeetupEventListAPIWorker
    private let favoriteWorker: MeetupEventFavoriteWorker = .shared
    
    private var historyEvents: [MeetupEventList.EventResponseItem] = []
    
    init(jsonAPIWorker: JsonAPIWorker = .init()) {
        fetchMeetupEventWorker = .init(jsonAPIWorker: jsonAPIWorker)
    }
    
    func fetchMeetupEvents(request: MeetupEventList.FetchEvents.Request) {
        fetchMeetupEventWorker.fetchMeetupEvents { [weak self] result in
            guard let self = self else { return }
            
            switch result {
            case .success(let events):
                var recentlyEvents: [MeetupEventList.EventResponseItem] = []
                var historyEvents: [MeetupEventList.EventResponseItem] = []
                
                events.forEach { event in
                    let favoriteState = self.favoriteWorker.getFavoriteState(withID: event.id)
                    if let date = event.date, Date().timeIntervalSince(date) < Constant.oneDay {
                        recentlyEvents.append((event, favoriteState))
                    } else {
                        historyEvents.append((event, favoriteState))
                    }
                }
                self.historyEvents = historyEvents
                
                let response: MeetupEventList.FetchEvents.Response = .init(
                    recentlyEvents: recentlyEvents,
                    historyEvents: historyEvents
                )
                self.presenter?.presentMeetupEvents(response: response)
            case .failure(let error):
                print(error)
            }
        }
    }
    
    func tapFavorite(request: MeetupEventList.TapFavorite.Request) {
        // TODO: 先用eventID取出這次要更新的meetupEvent
        // 將該event變更為相反的狀態，請favoriteWorker更新狀態，重新寫入historyEvents
        // 最後將Event交給presenter，請presenter更新 活動紀錄 類型的活動
        // 這邊可注意到，我們其實從一個use case的request，轉接到另一個use case
        
        //        historyEvents[safe: index] = newResponseItem
        presenter?.presentUpdateHistoryEvent(response: <#T##MeetupEventList.UpdateHistoryEvent.Response#>)
    }
    
    func subscribeFavoriteUpdate(request: MeetupEventList.SubscribeFavoriteUpdate.Request) {
        favoriteWorker.addObserver(self)
        // TODO: favoriteWorker addObserver，並在 MeetupEventFavorite Observer 那邊處理更新的資料
    }
    
    func unsubscribeFavoriteUpdate(request: MeetupEventList.UnsubscribeFavoriteUpdate.Request) {
        favoriteWorker.removeObserver(self)
    }
}

// MARK: - MeetupEventFavorite Observer
extension MeetupEventListInteractor: MeetupEventFavoriteObserver {
    
    func favoriteStateDidChanged(eventID: String, to newState: MeetupEventFavoriteState) {
        // TODO: 收到更新狀態的EventID與新的Favotire狀態，用類似tapFavorite的實作方式(但不用顛倒狀態)更新資料
        // 然後再請presenter更新 活動紀錄 類型的活動
        
        presenter?.presentUpdateHistoryEvent(response: <#T##MeetupEventList.UpdateHistoryEvent.Response#>)
    }
}

// MARK: - Test Only methods
extension MeetupEventListInteractor {
    
    // This function is a control point to reset dataSource in test environment.
    func cp_resetHistoryEvents(eventResponseItems: [MeetupEventList.EventResponseItem]) {
        self.historyEvents = eventResponseItems
    }
    
    // This function is a control point to reset persistenceWorker in test environment.
    func cp_resetFetchMeetupEventWorker(worker: MeetupEventListAPIWorker) {
        self.fetchMeetupEventWorker = worker
    }
}

// MARK: - Constants
extension MeetupEventListInteractor {
    
    private enum Constant {
        static let oneDay: TimeInterval = 3600 * 24
    }
}
