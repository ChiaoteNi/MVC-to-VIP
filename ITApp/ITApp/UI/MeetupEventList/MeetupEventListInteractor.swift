//
//  MeetupEventListInteractor.swift
//  ITApp
//
//  Created by Chiaote Ni on 2020/10/28.
//  Copyright (c) 2020 iOS@Taipei in iPlayground. All rights reserved.
//
//  This file was generated by iOS@Taipei's Clean Architecture Xcode Templates, which
//  is goaled to help you apply clean architecture to your iOS projects,
//

import Foundation

protocol MeetupEventListBusinessLogic {
    func fetchMeetupEvents(request: MeetupEventList.FetchEvents.Request)
    func tapFavorite(request: MeetupEventList.TapFavorite.Request)
    func subscribeFavoriteUpdate(request: MeetupEventList.SubscribeFavoriteUpdate.Request)
    func unsubscribeFavoriteUpdate(request: MeetupEventList.UnsubscribeFavoriteUpdate.Request)
}

final class MeetupEventListInteractor: MeetupEventListBusinessLogic {
    
    var presenter: MeetupEventListPresentationLogic?
    
    private var fetchMeetupEventWorker: MeetupEventListAPIWorker
    private let favoriteWorker: MeetupEventFavoriteWorker = .shared
    
    private var historyEvents: [MeetupEventList.EventResponseItem] = []
    
    init(jsonAPIWorker: JsonAPIWorker = .init()) {
        fetchMeetupEventWorker = .init(jsonAPIWorker: jsonAPIWorker)
    }
    
    func fetchMeetupEvents(request: MeetupEventList.FetchEvents.Request) {
        fetchMeetupEventWorker.fetchMeetupEvents { [weak self] result in
            guard let self = self else { return }
            
            switch result {
            case .success(let events):
                var recentlyEvents: [MeetupEventList.EventResponseItem] = []
                var historyEvents: [MeetupEventList.EventResponseItem] = []
                
                events.forEach { event in
                    let favoriteState = self.favoriteWorker.getFavoriteState(withID: event.id)
                    if let date = event.date, Date().timeIntervalSince(date) < Constant.oneDay {
                        recentlyEvents.append((event, favoriteState))
                    } else {
                        historyEvents.append((event, favoriteState))
                    }
                }
                self.historyEvents = historyEvents
                
                let response: MeetupEventList.FetchEvents.Response = .init(
                    recentlyEvents: recentlyEvents,
                    historyEvents: historyEvents
                )
                self.presenter?.presentMeetupEvents(response: response)
            case .failure(let error):
                print(error)
            }
        }
    }
    
    func tapFavorite(request: MeetupEventList.TapFavorite.Request) {
        guard
            let index = historyEvents.firstIndex (where: { $0.meetupEvent.id == request.meetupEventID }),
            let updateEvent = historyEvents[safe: index] else { return }
        
        let newState = !updateEvent.favoriteState
        let newResponseItem = (updateEvent.meetupEvent, newState)
        
        switch newState {
        case .favorite:
            favoriteWorker.addFavoriteMeetupEvent(with: updateEvent.meetupEvent.id)
        case .unfavorite:
            favoriteWorker.removeFavoriteMeetupEvent(with: updateEvent.meetupEvent.id)
        }
        
        historyEvents[safe: index] = newResponseItem
        
        let response: MeetupEventList.UpdateHistoryEvent.Response = .init(targetEvent: newResponseItem)
        presenter?.presentUpdateHistoryEvent(response: response)
    }
    
    func subscribeFavoriteUpdate(request: MeetupEventList.SubscribeFavoriteUpdate.Request) {
        favoriteWorker.addObserver(self)
    }
    
    func unsubscribeFavoriteUpdate(request: MeetupEventList.UnsubscribeFavoriteUpdate.Request) {
        favoriteWorker.removeObserver(self)
    }
}

// MARK: - MeetupEventFavorite Observer
extension MeetupEventListInteractor: MeetupEventFavoriteObserver {
    
    func favoriteStateDidChanged(eventID: String, to newState: MeetupEventFavoriteState) {
        guard
            let index = historyEvents.firstIndex (where: { $0.meetupEvent.id == eventID }),
            let updateEvent = historyEvents[safe: index] else { return }
        
        let newResponseItem = (updateEvent.meetupEvent, newState)
        historyEvents[safe: index] = newResponseItem
        
        let response: MeetupEventList.UpdateHistoryEvent.Response = .init(targetEvent: newResponseItem)
        presenter?.presentUpdateHistoryEvent(response: response)
    }
}

// MARK: - Test Only methods
extension MeetupEventListInteractor {
    
    // This function is a control point to reset dataSource in test environment.
    func cp_resetHistoryEvents(eventResponseItems: [MeetupEventList.EventResponseItem]) {
        self.historyEvents = eventResponseItems
    }
    
    // This function is a control point to reset persistenceWorker in test environment.
    func cp_resetFetchMeetupEventWorker(worker: MeetupEventListAPIWorker) {
        self.fetchMeetupEventWorker = worker
    }
}

// MARK: - Constants
extension MeetupEventListInteractor {
    
    private enum Constant {
        static let oneDay: TimeInterval = 3600 * 24
    }
}
